generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  GAMER
  CREATOR
  ADMIN
}

enum AssetType {
  MODEL_3D
  TEXTURE
  AUDIO
  ANIMATION
  PLUGIN
  OTHER
}

enum AssetStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
  REJECTED
}

enum Rarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
  MYTHICAL
}

enum Style {
  REALISTIC
  STYLIZED
  PIXEL
  LOW_POLY
  CARTOON
  ANIME
  OTHER
}

enum ModType {
  CHARACTER
  WEAPON
  VEHICLE
  BUILDING
  TERRAIN
  UI
  EFFECT
  OTHER
}

enum TransactionType {
  INITIAL_PURCHASE
  RESALE
  TRANSFER
  MINT
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

model User {
  id            Int    @id @default(autoincrement())
  email         String    @unique
  username      String    @unique
  password      String
  bio           String?
  profilePic    String?
  roles         Role[]    @default([GAMER])
  activeRole    Role      @default(GAMER)
  isEmailVerified Boolean  @default(false)
  isActive      Boolean   @default(true)
  lastLogin     DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  assets        Asset[]       @relation("CreatorAssets")
  purchases     Purchase[]
  likes         Like[]
  wishlist      Wishlist[]
  followers     Follow[]      @relation("followers")
  following     Follow[]      @relation("following")
  sentMessages  Message[]     @relation("sentMessages")
  receivedMessages Message[]   @relation("receivedMessages")
  notifications Notification[]
  reviews       Review[]
  refreshTokens RefreshToken[]

  // V2 Blockchain Relations
  ownerships     Ownership[]   @relation("UserOwnerships")
  soldTransactions Transaction[] @relation("TransactionsSeller")
  boughtTransactions Transaction[] @relation("TransactionsBuyer")

  // Optimized indexes
  @@index([activeRole])
  @@index([isActive])
  @@index([createdAt])
  @@index([lastLogin])
}

model Asset {
  id            String      @id @default(uuid())
  title         String
  description   String
  type          AssetType

  // Structured metadata for filtering
  game          String?
  rarity        Rarity?
  style         Style?
  modType       ModType?

  // Flexible tagging system
  tags          String[]

  // Additional metadata as JSON for extensibility
  metadata      Json?       // Store additional properties like polyCount, textureSize, rigged, etc.

  price         Float
  discountPrice Float?      // Keep for V2
  thumbnail     String
  previewUrl    String?
  fileUrl       String
  fileSize      Int
  status        AssetStatus @default(DRAFT)
  isFeatured    Boolean     @default(false)
  downloadCount Int         @default(0)
  viewCount     Int         @default(0)
  likeCount     Int         @default(0)

  // Version control for updates
  version       String      @default("1.0.0")

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  creatorId     Int
  creator       User        @relation("CreatorAssets", fields: [creatorId], references: [id])
  purchases     Purchase[]
  likes         Like[]
  wishlist      Wishlist[]
  categories    Category[]  @relation()
  reviews       Review[]
  assets        AssetFile[]

  // V2 Blockchain Relations
  ownerships    Ownership[] @relation("AssetOwnerships")
  transactions  Transaction[] @relation("AssetTransactions")

  // Optimized indexes for filtering and sorting
  @@index([status, isFeatured])
  @@index([type, status])
  @@index([creatorId, status])
  @@index([game, type])
  @@index([type])
  @@index([game])
  @@index([rarity])
  @@index([style])
  @@index([modType])
  @@index([status])
  @@index([isFeatured])
  @@index([createdAt])
  @@index([downloadCount])
  @@index([likeCount])
  @@index([price])
}

model AssetFile {
  id          Int   @id @default(autoincrement())
  name        String
  url         String
  fileType    String
  fileSize    Int
  isPrimary   Boolean  @default(false)
  assetId     String
  asset       Asset    @relation(fields: [assetId], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Category {
  id          Int   @id @default(autoincrement())
  name        String   @unique
  slug        String   @unique
  description String?
  assets      Asset[]
  parentId    Int?
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Purchase {
  id            Int   @id @default(autoincrement())
  userId        Int
  user          User     @relation(fields: [userId], references: [id])
  assetId       String
  asset         Asset    @relation(fields: [assetId], references: [id])
  amount        Float
  status        String   @default("COMPLETED")
  paymentMethod String?
  transactionId String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([userId, assetId])
}

// V2 Blockchain Support Models
model Ownership {
  id            Int    @id @default(autoincrement())
  userId        Int
  user          User      @relation("UserOwnerships", fields: [userId], references: [id])
  assetId       String
  asset         Asset     @relation("AssetOwnerships", fields: [assetId], references: [id])
  tokenId       String?   // NFT token ID if blockchain
  contractAddress String? // Smart contract address
  quantity      Int       @default(1) // For limited edition assets
  acquiredAt    DateTime  @default(now())
  isActive      Boolean   @default(true) // False when sold/transferred
  
  // Blockchain metadata
  blockchainTxHash String?
  blockNumber      Int?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  transactions  Transaction[]

  @@unique([userId, assetId, tokenId])
  @@index([userId])
  @@index([assetId])
}

model Transaction {
  id              Int      @id @default(autoincrement())
  type            TransactionType
  
  // Parties involved
  sellerId        Int?
  seller          User?       @relation("TransactionsSeller", fields: [sellerId], references: [id])
  buyerId         Int
  buyer           User        @relation("TransactionsBuyer", fields: [buyerId], references: [id])
  
  // Asset details
  assetId         String
  asset           Asset       @relation("AssetTransactions", fields: [assetId], references: [id])
  ownershipId     Int?
  ownership       Ownership?  @relation(fields: [ownershipId], references: [id])
  
  // Financial
  amount          Float
  platformFee     Float       @default(0)
  creatorRoyalty  Float       @default(0)
  
  // Payment & Blockchain
  paymentMethod   String?
  paymentStatus   PaymentStatus @default(PENDING)
  blockchainTxHash String?
  blockNumber     Int?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@index([sellerId])
  @@index([buyerId])
  @@index([assetId])
}

model Like {
  userId    Int
  user      User   @relation(fields: [userId], references: [id])
  assetId   String
  asset     Asset  @relation(fields: [assetId], references: [id])
  createdAt DateTime @default(now())

  @@id([userId, assetId])
}

model Wishlist {
  userId    Int
  user      User   @relation(fields: [userId], references: [id])
  assetId   String
  asset     Asset  @relation(fields: [assetId], references: [id])
  createdAt DateTime @default(now())

  @@id([userId, assetId])
}

model Follow {
  followerId  Int
  follower    User   @relation("followers", fields: [followerId], references: [id])
  followingId Int
  following   User   @relation("following", fields: [followingId], references: [id])
  createdAt   DateTime @default(now())

  @@id([followerId, followingId])
}

model Review {
  id        Int   @id @default(autoincrement())
  rating    Int
  comment   String?
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  assetId   String
  asset     Asset    @relation(fields: [assetId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, assetId])
}

model Message {
  id           Int   @id @default(autoincrement())
  content      String
  senderId     Int
  sender       User     @relation("sentMessages", fields: [senderId], references: [id])
  recipientId  Int
  recipient    User     @relation("receivedMessages", fields: [recipientId], references: [id])
  isRead       Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model Notification {
  id        Int   @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  title     String
  message   String
  isRead    Boolean  @default(false)
  type      String
  relatedId String?
  createdAt DateTime @default(now())
}

model RefreshToken {
  id          Int   @id @default(autoincrement())
  userId      Int
  user        User     @relation(fields: [userId], references: [id])
  token       String   @unique
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}